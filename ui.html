<html>
  <head>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        user-select: none;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 10;
      }
      .btn {
        background: #ffffffdd;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 14px;
        cursor: pointer;
        text-align: center;
      }
      .zoom-indicator {
        margin-top: 5px;
        font-size: 12px;
        text-align: center;
        color: #333;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="minimap" width="300" height="300"></canvas>

    <div id="controls">
      <div class="btn" id="zoom-in">+</div>
      <div class="btn" id="zoom-out">â€“</div>
      <div class="btn" id="zoom-reset">Reset</div>
      <div class="zoom-indicator" id="zoom-indicator">100%</div>
    </div>

    <script>
      const canvas = document.getElementById('minimap');
      const ctx = canvas.getContext('2d');

      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      const resetBtn = document.getElementById('zoom-reset');
      const zoomIndicator = document.getElementById('zoom-indicator');

      let nodes = [];
      let viewport = {};
      let minimapZoom = 1.0;

      const margin = 20;
      let offsetX = 0;
      let offsetY = 0;
      let scale = 1;
      let isDragging = false;

      // Para arrastrar con clic derecho
      let isRightDragging = false;
      let rightDragStart = { x: 0, y: 0 };
      let offsetStart = { x: 0, y: 0 };

      onmessage = (event) => {
        const msg = event.data.pluginMessage;
        if (msg.type === 'init') {
          viewport = msg.viewport;
          nodes = msg.nodes;
          // Reset offset al recibir datos para que no quede desplazado si cambian nodos
          offsetX = 0;
          offsetY = 0;
          draw();
        }
      };

      function draw() {
        if (!nodes.length || !viewport.bounds) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f2f2f2';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const bounds = getCanvasBounds(nodes);
        const scaleBase = getScale(bounds, canvas.width - margin * 2, canvas.height - margin * 2);
        scale = scaleBase * minimapZoom;

        // Calculamos offset considerando desplazamiento con clic derecho
        const baseOffsetX = margin - bounds.minX * scale;
        const baseOffsetY = margin - bounds.minY * scale;

        // Sumamos offset por desplazamiento (clic derecho)
        const totalOffsetX = baseOffsetX + offsetX;
        const totalOffsetY = baseOffsetY + offsetY;

        // Dibujamos nodos
        ctx.fillStyle = "#ccc";
        nodes.forEach(n => {
          ctx.fillRect(
            n.x * scale + totalOffsetX,
            n.y * scale + totalOffsetY,
            n.width * scale,
            n.height * scale
          );
        });

        // Dibujamos viewport
        const vb = viewport.bounds;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          vb.x * scale + totalOffsetX,
          vb.y * scale + totalOffsetY,
          vb.width * scale,
          vb.height * scale
        );

        zoomIndicator.textContent = Math.round(minimapZoom * 100) + '%';
      }

      function getCanvasBounds(nodes) {
        const allX = nodes.flatMap(n => [n.x, n.x + n.width]);
        const allY = nodes.flatMap(n => [n.y, n.y + n.height]);
        return {
          minX: Math.min(...allX),
          maxX: Math.max(...allX),
          minY: Math.min(...allY),
          maxY: Math.max(...allY),
        };
      }

      function getScale(bounds, maxWidth, maxHeight) {
        const contentWidth = bounds.maxX - bounds.minX;
        const contentHeight = bounds.maxY - bounds.minY;
        return Math.min(maxWidth / contentWidth, maxHeight / contentHeight);
      }

      function handleDrag(e) {
        const baseOffsetX = margin - getCanvasBounds(nodes).minX * scale;
        const baseOffsetY = margin - getCanvasBounds(nodes).minY * scale;
        const totalOffsetX = baseOffsetX + offsetX;
        const totalOffsetY = baseOffsetY + offsetY;

        const x = (e.offsetX - totalOffsetX) / scale;
        const y = (e.offsetY - totalOffsetY) / scale;

        parent.postMessage({
          pluginMessage: {
            type: 'move-to',
            x,
            y
          }
        }, '*');
      }

      canvas.addEventListener("contextmenu", e => e.preventDefault());

      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 2) { // clic derecho
          isRightDragging = true;
          rightDragStart = { x: e.clientX, y: e.clientY };
          offsetStart = { x: offsetX, y: offsetY };
        } else if (e.button === 0) { // clic izquierdo
          isDragging = true;
          handleDrag(e);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isRightDragging) {
          const dx = e.clientX - rightDragStart.x;
          const dy = e.clientY - rightDragStart.y;

          offsetX = offsetStart.x + dx;
          offsetY = offsetStart.y + dy;

          draw();
        } else if (isDragging) {
          handleDrag(e);
        }
      });

      canvas.addEventListener("mouseup", (e) => {
        if (e.button === 2) {
          isRightDragging = false;
        } else if (e.button === 0) {
          isDragging = false;
          parent.postMessage({ pluginMessage: { type: 'move-complete' } }, '*');
        }
      });

      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
        isRightDragging = false;
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
          minimapZoom = Math.min(minimapZoom * 1.1, 5);
        } else {
          minimapZoom = Math.max(minimapZoom / 1.1, 0.2);
        }
        draw();
      });

      zoomInBtn.onclick = () => {
        minimapZoom = Math.min(minimapZoom * 1.1, 5);
        draw();
      };

      zoomOutBtn.onclick = () => {
        minimapZoom = Math.max(minimapZoom / 1.1, 0.2);
        draw();
      };

      resetBtn.onclick = () => {
        minimapZoom = 1.0;
        offsetX = 0;
        offsetY = 0;
        draw();
      };
    </script>
  </body>
</html>
