<html>
  <head>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        user-select: none;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 10;
      }
      .btn {
        background: #ffffffdd;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 14px;
        cursor: pointer;
        text-align: center;
      }
      .zoom-indicator {
        margin-top: 5px;
        font-size: 12px;
        text-align: center;
        color: #333;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="minimap" width="300" height="300"></canvas>

    <div id="controls">
      <div class="btn" id="zoom-in">+</div>
      <div class="btn" id="zoom-out">–</div>
      <div class="btn" id="zoom-reset">Reset</div>
      <div class="zoom-indicator" id="zoom-indicator">100%</div>
    </div>

    <script>
      const canvas = document.getElementById('minimap');
      const ctx = canvas.getContext('2d');

      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      const resetBtn = document.getElementById('zoom-reset');
      const zoomIndicator = document.getElementById('zoom-indicator');

      let nodes = [];
      let viewport = {};
      let minimapZoom = 1.0;

      let scale = 1;
      const margin = 20;

      // Desplazamiento manual del canvas del minimapa (pan)
      let panOffsetX = 0;
      let panOffsetY = 0;

      // Flags de interacción
      let isDragging = false;
      let isRightDragging = false;
      let rightDragStart = { x: 0, y: 0 };
      let offsetStart = { x: 0, y: 0 };

      onmessage = (event) => {
        const msg = event.data.pluginMessage;
        if (msg.type === 'init') {
          viewport = msg.viewport;
          nodes = msg.nodes;
          draw();
        }
      };

      function draw() {
        if (!nodes.length || !viewport.bounds) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f2f2f2';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const bounds = getCanvasBounds(nodes);
        const scaleBase = getScale(bounds, canvas.width - margin * 2, canvas.height - margin * 2);
        scale = scaleBase * minimapZoom;

        // Centrar viewport en canvas
        const vb = viewport.bounds;
        const viewportCenterX = vb.x + vb.width / 2;
        const viewportCenterY = vb.y + vb.height / 2;

        const canvasCenterX = canvas.width / 2;
        const canvasCenterY = canvas.height / 2;

        const baseOffsetX = canvasCenterX - viewportCenterX * scale;
        const baseOffsetY = canvasCenterY - viewportCenterY * scale;

        const offsetX = baseOffsetX + panOffsetX;
        const offsetY = baseOffsetY + panOffsetY;

        // Dibujar nodos
        ctx.fillStyle = "#ccc";
        nodes.forEach(n => {
          ctx.fillRect(
            n.x * scale + offsetX,
            n.y * scale + offsetY,
            n.width * scale,
            n.height * scale
          );
        });

        // Dibujar viewport
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.strokeRect(
          vb.x * scale + offsetX,
          vb.y * scale + offsetY,
          vb.width * scale,
          vb.height * scale
        );

        zoomIndicator.textContent = Math.round(minimapZoom * 100) + '%';
      }

      function getCanvasBounds(nodes) {
        const allX = nodes.flatMap(n => [n.x, n.x + n.width]);
        const allY = nodes.flatMap(n => [n.y, n.y + n.height]);
        return {
          minX: Math.min(...allX),
          maxX: Math.max(...allX),
          minY: Math.min(...allY),
          maxY: Math.max(...allY),
        };
      }

      function getScale(bounds, maxWidth, maxHeight) {
        const contentWidth = bounds.maxX - bounds.minX;
        const contentHeight = bounds.maxY - bounds.minY;
        return Math.min(maxWidth / contentWidth, maxHeight / contentHeight);
      }

      function handleDrag(e) {
        const bounds = getCanvasBounds(nodes);
        const scaleBase = getScale(bounds, canvas.width - margin * 2, canvas.height - margin * 2);
        scale = scaleBase * minimapZoom;

        const vb = viewport.bounds;
        const viewportCenterX = vb.x + vb.width / 2;
        const viewportCenterY = vb.y + vb.height / 2;

        const canvasCenterX = canvas.width / 2;
        const canvasCenterY = canvas.height / 2;

        const baseOffsetX = canvasCenterX - viewportCenterX * scale;
        const baseOffsetY = canvasCenterY - viewportCenterY * scale;

        const offsetX = baseOffsetX + panOffsetX;
        const offsetY = baseOffsetY + panOffsetY;

        const x = (e.offsetX - offsetX) / scale;
        const y = (e.offsetY - offsetY) / scale;

        parent.postMessage({
          pluginMessage: {
            type: 'move-to',
            x,
            y
          }
        }, '*');
      }

      // Interacción mouse
      canvas.addEventListener("contextmenu", e => e.preventDefault());

      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 2) {
          isRightDragging = true;
          rightDragStart = { x: e.clientX, y: e.clientY };
          offsetStart = { x: panOffsetX, y: panOffsetY };
        } else if (e.button === 0) {
          isDragging = true;
          handleDrag(e);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isRightDragging) {
          const dx = e.clientX - rightDragStart.x;
          const dy = e.clientY - rightDragStart.y;
          panOffsetX = offsetStart.x + dx;
          panOffsetY = offsetStart.y + dy;
          draw();
        } else if (isDragging) {
          handleDrag(e);
        }
      });

      canvas.addEventListener("mouseup", (e) => {
        if (e.button === 2) {
          isRightDragging = false;
        } else if (e.button === 0) {
          isDragging = false;
          parent.postMessage({ pluginMessage: { type: 'move-complete' } }, '*');
        }
      });

      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
        isRightDragging = false;
      });

      // Zoom con scroll
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        if (e.deltaY < 0) {
          minimapZoom = Math.min(minimapZoom * 1.1, 5);
        } else {
          minimapZoom = Math.max(minimapZoom / 1.1, 0.2);
        }
        draw();
      });

      // Zoom con botones
      zoomInBtn.onclick = () => {
        minimapZoom = Math.min(minimapZoom * 1.1, 5);
        draw();
      };

      zoomOutBtn.onclick = () => {
        minimapZoom = Math.max(minimapZoom / 1.1, 0.2);
        draw();
      };

      resetBtn.onclick = () => {
        minimapZoom = 1.0;
        panOffsetX = 0;
        panOffsetY = 0;
        draw();
      };
    </script>
  </body>
</html>
